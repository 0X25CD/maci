<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Minimum Anti-Collusion Infrastructure</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="spec.html"><strong aria-hidden="true">2.</strong> Specification</a></li><li class="chapter-item expanded "><a href="installation.html"><strong aria-hidden="true">3.</strong> Installation</a></li><li class="chapter-item expanded "><a href="cli.html"><strong aria-hidden="true">4.</strong> Command-line interface</a></li><li class="chapter-item expanded "><a href="circuits.html"><strong aria-hidden="true">5.</strong> Circuits</a></li><li class="chapter-item expanded "><a href="trustedsetup.html"><strong aria-hidden="true">6.</strong> Trusted setup</a></li><li class="chapter-item expanded "><a href="testing.html"><strong aria-hidden="true">7.</strong> Testing</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Minimum Anti-Collusion Infrastructure</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Minimum Anti-Collusion Infrastructure (MACI) is a base layer for
bribery-resistant, secure, and private digital voting.</p>
<p>The documentation here pertains to version 1.0, temporarily located in the <code>v1</code>
branch.</p>
<p>Applications like <a href="https://clr.fund/">clr.fund</a> build atop MACI to increase
privacy and discourage bribery for public goods funding.</p>
<p>MACI offers the following guarantees:</p>
<ul>
<li><strong>Collusion resistance</strong>: no-one except a trusted coordinator should be
certain of the validity of a vote, reducing the effectiveness of bribery.</li>
<li><strong>Receipt-freeness</strong>: no-one voter prove (besides to the coordinator) which
way they voted.</li>
<li><strong>Privacy</strong>: no-one except a trusted coordinator should be able to decrypt a
vote.</li>
<li><strong>Uncensorability</strong>: no-one — not even the trusted coordinator — should be
able to censor a vote.</li>
<li><strong>Unforgeability</strong>: only the owner of a user's private key may cast a vote
tied to its corresponding public key.</li>
<li><strong>Non-repudiation</strong>: no-one may modify or delete a vote after it is cast,
although a user may cast another vote to nullify it.</li>
<li><strong>Correct execution</strong>: no-one — not even the trusted coordinator — should be
able to produce a false tally of votes.</li>
</ul>
<p>Under the hood, MACI uses Ethereum smart contracts and zero-knowledge proofs.
It inherits security and uncensorability from the underlying Ethereum
blockchain, ensures unforgeability via asymmetric encryption, and achieves
collusion resistance, privacy, and correct execution via zk-SNARK proofs.</p>
<p>Although MACI can provide collusion resistance only if the coordinator is
honest, a dishonest coordinator can neither censor nor tamper with its
execution.</p>
<p>Note that MACI presumes an identity system where each legitimate member
controls a unique Ethereum private key.</p>
<p>MACI was originally proposed by Vitalik Buterin in <a href="https://ethresear.ch/t/minimal-anti-collusion-infrastructure/5413">this ethresear.ch
post</a>.</p>
<h2 id="credits"><a class="header" href="#credits">Credits</a></h2>
<ul>
<li><a href="https://github.com/barryWhiteHat">Barry WhiteHat</a></li>
<li><a href="https://github.com/corydickson">Cory Dickson</a></li>
<li><a href="https://twitter.com/ChihChengLiang">Chih-Cheng Liang</a></li>
<li><a href="https://han0110.github.io/">Han Jian</a></li>
<li><a href="https://kndrck.co/">Kendrick Tan</a></li>
<li><a href="https://github.com/xuhcc">Kirill Goncharov</a></li>
<li><a href="http://kobi.one/">Kobi Gurkan</a></li>
<li><a href="https://kohweijie.com">Koh Wei Jie</a></li>
</ul>
<h1 id="specification"><a class="header" href="#specification">Specification</a></h1>
<h2 id="user-flow"><a class="header" href="#user-flow">User flow</a></h2>
<p>Whitelisted voters named Alice and Bob register to vote by sending their public
key to the MACI smart contract. Additionally, there is a central coordinator
Charlie, whose public key is known to all.</p>
<p>When Alice casts her vote, she signs her vote with her private key, encrypts
her signature with Charlie's public key, and submits the result to the smart
contract.</p>
<p>Each voter may change her keypair at any time. To do this, she creates and
signs a key-change command, encrypts it, and sends it to the smart contract.
This makes it impossible for a briber to ever be sure that their bribe has any
effect on the bribee's vote.</p>
<p>If Bob, for instance, bribes Alice to vote a certain way, she can simply use
the first public key she had registered ⁠— which is now void ⁠— to cast a vote.
Since said vote is encrypted, as was the key-changing message which Alice had
previously sent to Charlie, Bob has no way to tell if Alice had indeed voted
the way he wanted her to.</p>
<p>Even if Alice reveals the plaintext of her vote to Bob, she just needs to not
show him the updated key command that she previously used to invalidate that
key. In short, as long as she had submitted a single encrypted command before
her vote, there is no way to tell if said vote is valid or not.</p>
<h2 id="polls-and-ballots"><a class="header" href="#polls-and-ballots">Polls and Ballots</a></h2>
<p>A <strong>Poll</strong> is the process by which users cast their votes on a single set of
vote options. It is akin to a referendum or election.</p>
<p>A <strong>Ballot</strong> represents a particular user's votes in a Poll, as well as their
next valid nonce. It is akin to a voting slip, which belongs to only one voter
and contains a list of their choices.</p>
<p>A MACI instance can have multiple Polls and multiple users. Each Poll may have
multiple Ballots, but each user may only have one Ballot per poll.</p>
<p>For example, a user Alice may participate in two Polls. In Poll A, she can cast
a vote for Party A, and in Poll B, she can cast a vote for Party B. Alice's
Ballot for Poll A should only reflect her vote for Party A (as well as her
nonce), and her Ballot for Poll B should only reflect her vote for Party B (and
her nonce).</p>
<p>Sign-ups are perpetual — that is, there is no deadline. The only limit is the
capacity of the state tree, which is hardcoded to <code>5 ^ 10</code> (9.7 million).</p>
<p>When a user signs up to MACI, they can only vote in Polls whose voting period
has not expired, as well as all future Polls. For instance, if Bob signs up on
1 December 2020, and only Poll C is currently accepting votes, he can vote for
Poll C. Bob, however, cannot vote for Poll A or Poll B. Nevertheless, when Poll
D and future polls are created, he can vote for them.</p>
<h2 id="technical-process"><a class="header" href="#technical-process">Technical process</a></h2>
<h3 id="maci-deployment"><a class="header" href="#maci-deployment">MACI deployment</a></h3>
<h4 id="signup-gatekeeper-deployment"><a class="header" href="#signup-gatekeeper-deployment">Signup gatekeeper deployment</a></h4>
<p>The signup gatekeeper is a way for the coordinator to define their own logic to
allowing or disallow a particular Ethereum address be used to sign up. The
signup gatekeeper contract inherits from the abstract contract
<code>SignUpGatekeeper</code> which defines a virtual function <code>register(address, bytes memory)</code> that must be implemented. The bytes <code>data</code> can be anything, such as an
ABI-encoded ERC-721 token ID or address of an ERC20 governence token.</p>
<p>There are two sample signup gatekeepers that MACI provides by default. Clients
should implement their own.</p>
<h5 id="freeforallgatekeeper"><a class="header" href="#freeforallgatekeeper"><code>FreeForAllGatekeeper</code></a></h5>
<p>This signup gatekeeper allows anyone to sign up without restriction.</p>
<h5 id="signuptokengatekeeper"><a class="header" href="#signuptokengatekeeper"><code>SignUpTokenGatekeeper</code></a></h5>
<p>This signup gatekeeper restricts signups to addresses which own a certain
ERC-721 token.</p>
<p>To deploy this contract on a testnet, a user needs to create an instance of
<code>SignUpToken</code> and pass that into the gatekeeper contract constructor. </p>
<p>Be sure to mint a token and send it to the user that will sign up by calling
<code>giveToken</code> prior to registration. They will need Keccak256 hash of their token
ID which they will use in the MACI contract's <code>signUp()</code> method that will
forward these bytes to the gatekeeper contract.</p>
<h4 id="voice-credit-proxy-deployment"><a class="header" href="#voice-credit-proxy-deployment">Voice credit proxy deployment</a></h4>
<p>The voice credit proxy that defines the total number of voice credits available
to each user. Clients should implement and deploy their own voice credit proxy
for their use case. An example of a voice credit proxy is a contract that reads
an address's ERC20 token balance.</p>
<p>Currently, the MACI contract only supports <code>2 ^ 32</code> voice credits as this is
hardcoded in the state tree update circuit.</p>
<p>The voice credit proxy should inherit from the abstract
<code>InitialVoiceCreditProxy</code> contract and override the function
<code>getVoiceCredits(address, bytes memory)</code>, which returns a <code>uint256</code> which must
be less than <code>2 ^ 32</code>.</p>
<p>An example of a voice credit proxy is <code>ConstantInitialVoiceCreditProxy</code>. It
allows the deployer to set the voice credit balance to a constant value.</p>
<p>However, if a coordinator chooses to allow varying max voice credits for
particular users they can implement <code>InitialVoiceCreditProxy</code> using an override
of <code>getVoiceCredits</code>. Once again, the bytes field gives the option to get
creative with other contracts that may track or help in the calculation of this
information.</p>
<h3 id="poll-creation"><a class="header" href="#poll-creation">Poll creation</a></h3>
<p>Each MACI contract can theoretically support up to <code>2 ^ 50</code> polls.</p>
<p><img src="https://hackmd.io/_uploads/B1s-NlShw.png" alt="" /></p>
<p>The MACI contract itself wraps this process in the <code>deployPoll</code> method where
one would specify the max batch size. </p>
<p>Coordinator creates a new poll by deploying the contract using a <code>PollFactory</code>
which will allow said address to be the owner which will give them access to
the <code>deploy()</code> method.</p>
<p><strong>Note:</strong> the coordinator will need to instantiate the verification key
registry <code>VkRegistry</code>, and <code>AccQueue</code> which handles the logic for processing
the merkle tree of states.</p>
<p>This function will deploy an instance of the <code>AccQueueQuinaryMaci</code> for the
messages merkle tree using the specified the <code>messageTreeSubDepth</code> in the
<code>TreeDepths</code> domain object. The poll contract will be the owner of the message
queue. </p>
<p>Aside from setting the empty ballot tree root and transfering ownership,
certain criteria for the parameters must be satisfied to successfully deploy
the <code>Poll</code> contract.</p>
<p>Namely, the max number of users must not exceed <code>5 ^ maxTreeDepth</code> (all Merkle
trees in MACI have an arity of five) to ensure there is a valid Merkle root for
each public key provided by a potential voter. This includes both the state,
message, and vote option tree. Furthermore the maximum number of messages must
be greater than the max batch size as will as be a factor, so that there is a
guarentee that all of the leaves can be queued for processing. </p>
<p>Given all this information the process verifying key and the tallying verfiying
key will be generated and set inside the <code>VkRegistry</code>. </p>
<h4 id="sign-ups"><a class="header" href="#sign-ups">Sign-ups</a></h4>
<p><strong>Note:</strong> The following sections assume the coordinator has deployed an
instance of MACI with the contracts outlined above, including the <code>VkRegistry</code>,
and has called <code>init</code> successfully. </p>
<p>Given a user's public key as well as necessary bytes data for the respective
gateway whitelist procedure and voice credit balance, the contract attempts to
queue a state leaf for a voter.</p>
<p>To perform a successful signature for proofs the contract must enforce that
both points in the public key be less than the <code>SNARK_SCALAR_FIELD</code> used to
generate the circuit. </p>
<p>In the current implementation, no voter is allowed to exceed <code>2 ^ 32</code> voice
credits, this may be increased in later versions. The section describing
command hashing will go into this in more detail.</p>
<p>When these operations complete sucessfully an event <code>SignUp</code> is emitted
containing the current state index, the submitted public key, and the
intialized voice credit balance.</p>
<h4 id="voting"><a class="header" href="#voting">Voting</a></h4>
<p>User publishes a message to a specific <code>Poll</code> contract. The method
<code>publishMessage</code> receives both the message to publish as well as the voters
ephemeral public key which peforms the scalar checks described in the previous
section. Once the message is hashed it is then added to the message queue and
an event is emitted containing the original message as well as the public key.
This method will not succeed if called after the voting deadline, so the time
passed from deployment is less than the maximum duration set. </p>
<h3 id="merge-queues"><a class="header" href="#merge-queues">Merge queues</a></h3>
<p>Coordinator merges the state and message queus by interacting with the <code>Poll</code>
contract which interfaces with <code>MessageProcessor</code>. The following methods can
only be called on the successful resolution of the <code>isAfterVotingDeadline</code>
modifier which checks to see if enough time has passed from the specified
voting <code>duration</code>.</p>
<p>As specified previously, when a message is published the message leaf is queued
for processing. The method <code>mergeSubRoots</code> is responsible for forming the
shortest possible state tree. If <code>numSrQueueOps</code> is zero then it will try to
merge all the subtrees in a single transaction. It does this by queuing as many
subtree roots for processing. However, the coordinator can specify a value
greater than zero, then this function can be called however many times as
necessary to reduce the tree state. This is useful when there are too many
subtrees that need to merged where a single transaction may run out of gas.</p>
<p>Once this step is completed, the <code>Poll</code> contract can finally reconcile the main
tree with the max tree depth specified by calling <code>merge(uint256 _depth)</code></p>
<h3 id="message-processing"><a class="header" href="#message-processing">Message processing</a></h3>
<p>TODO</p>
<h3 id="vote-tallying"><a class="header" href="#vote-tallying">Vote tallying</a></h3>
<p>TODO</p>
<h3 id="result-verification"><a class="header" href="#result-verification">Result verification</a></h3>
<p>TODO</p>
<h2 id="cryptographic-operations"><a class="header" href="#cryptographic-operations">Cryptographic operations</a></h2>
<h3 id="key-generation"><a class="header" href="#key-generation">Key generation</a></h3>
<p>Each user owns an EdDSA keypair, as does the coordinator. Every user should
have a copy of the coordinator's public key, which is stored and available from
the smart contract. Likewise, the coordinator should have a copy of each user's
public key, which they publish on-chain to sign up.</p>
<p>We define an EdDSA private key as a random value (initially 256 bits large)
modulo the snark field size as described in
<a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-197.md">EIP197</a>. This
results in a key size of roughly 253 bits and no more than 254 bits.
Additionally, we use <a href="http://cvsweb.openbsd.org/cgi-bin/cvsweb/%7Echeckout%7E/src/lib/libc/crypt/arc4random_uniform.c">this efficient
algorithm</a>
to prevent modulo bias.</p>
<h3 id="hashing"><a class="header" href="#hashing">Hashing</a></h3>
<p>MACI uses <a href="https://github.com/iden3/circomlib">iden3's implementation</a> of the
<a href="https://github.com/iden3/circomlib">Poseidon hash function</a> to build the state
and message AccQueues and Merkle trees. Poseidon is a snark-friendly hash
function as it requires a small number of circuit constraints, as opposed to
CPU-friendly hash functions such as SHA256. The tradeoff is that Poseidon
consumes a lot of gas in the EVM (which is why MACI uses AccQueues instead of
incremental Merkle trees, as described in a different section of this
document).</p>
<p>MACI has more than one Poseidon hash function — one for a different number of
inputs (from 2 to 5). It uses <code>circomlib</code>'s <code>poseidon_gencontract.js</code> script to
generate EVM bytecode for each function. Additionally, the <code>maci-crypto</code> module
provides corresponding wrapper functions, and the <code>maci-domainobjs</code> module
abstracts the actual use of Poseidon from developers (for instance, the
<code>Command</code> class contains a <code>hash()</code> function which invokes a Poseidon hash
function that accepts 4 inputs, but the developer does not need to be concerned
about the number of inputs).</p>
<h3 id="command-signing"><a class="header" href="#command-signing">Command signing</a></h3>
<p>We use the EdDSA scheme to allow users to sign their commands. We <a href="https://github.com/iden3/circomlib/blob/master/src/eddsa.js">modified
iden3's EdDSA
implementation</a> to
use Poseidon (t=2) instead of Blake512 to hash the user's private key and
convert the message to an elliptic curve point.</p>
<p>More information about iden3's EdDSA scheme can be found in <a href="https://iden3-docs.readthedocs.io/en/latest/_downloads/a04267077fb3fdbf2b608e014706e004/Ed-DSA.pdf">this
paper</a>.</p>
<h3 id="command-encryption"><a class="header" href="#command-encryption">Command encryption</a></h3>
<p>To encrypt a command, we first use
<a href="https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman">ECDH</a> in
the BabyJub elliptic curve to generate a shared key.</p>
<p>Each command should be encrypted with a unique shared key. When the user
publishes a message (i.e. casts a vote), they generate an ephemeral keypair
with private key \(eSk\) and public key \(ePk\).</p>
<p>The shared key \(k\) is generated using the coordinator's public key \(cPk\) and
the user's ephemeral private key \(eSk\).</p>
<p>Next we use MiMC7 to encrypt the command and signature with \(k\).</p>
<p>The user sends their ephemeral public key \(ePk\) along with the ciphertext.
The coordinator can recover the same shared key using their private key
\(cSk\) and the given ephemeral public key \(ePk\).</p>
<p>In summary:</p>
<ul>
<li>Coordinator has \(cPk\), \(cSk\).</li>
<li>User generates a unique \(ePk\), \(eSk\).</li>
<li>Using ECDH, the user generates \(k\) using \(eSk\) and \(cPk\).</li>
<li>The user encrypts their command with \(k\), and publishes the ciphertext and
\(ePk\) to the MACI contract.</li>
<li>The coordinator generates \(k\) using \(ePk\) and \(cSk\), and can therefore
decrypt the ciphertext.</li>
</ul>
<h3 id="zk-snarks"><a class="header" href="#zk-snarks">zk-SNARKs</a></h3>
<p>MACI uses the Groth16 zk-SNARK construction on the BN245 pairing-friendly
curve. Its circuits are written in the
<a href="https://github.com/iden3/circom"><code>circom</code></a> language.</p>
<p>If time permits, we will perform a trusted setup for the circuits. Phase 1 of
the trusted setup will use the latest verified output of the <a href="https://github.com/weijiekoh/perpetualpowersoftau">Perpetual Powers
of Tau ceremony</a>. Phase 2
will ideally be run with the help of a user interface that allows for multiple
circuit setups in one go. This UI is a separate project, which is a work in
progress.</p>
<h3 id="nothing-up-my-sleeve-value"><a class="header" href="#nothing-up-my-sleeve-value">Nothing-up-my sleeve value</a></h3>
<p>The state queue and message queue both use a <a href="https://en.wikipedia.org/wiki/Nothing-up-my-sleeve_number">nothing-up-my-sleeve
value</a> as the
default leaf. This value is:</p>
<pre><code>8370432830353022751713833565135785980866757267633941821328460903436894336785
</code></pre>
<p>which is the Keccak256 hash of the UTF-8 string <code>Maci</code>. The Typescript code
used to generate it is:</p>
<pre><code class="language-ts">BigInt(ethers.utils.solidityKeccak256(
    ['bytes'],
    [ethers.utils.toUtf8Bytes('Maci')])
) % SNARK_FIELD_SIZE
</code></pre>
<p>where <code>SNARK_FIELD_SIZE</code> is the <a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-197.md">BN254 group order
<code>p</code></a>, equal to:</p>
<pre><code>21888242871839275222246405745257275088548364400416034343698204186575808495617
</code></pre>
<h2 id="data-structures-and-domain-objects"><a class="header" href="#data-structures-and-domain-objects">Data structures and domain objects</a></h2>
<h3 id="accqueue"><a class="header" href="#accqueue">AccQueue</a></h3>
<p>An <em>AccQueue</em> enables MACI to build incremental Merkle trees cheaply. The
AccQueue was originally proposed by Barry Whitehat in <a href="https://ethresear.ch/t/batch-deposits-for-op-zk-rollup-mixers-maci/6883">this
post</a>.
Previously, MACI used incremental Merkle trees. When a user signed up or
published a message, the MACI contract would insert a leaf value at the next
unmodified index. This involved the same number of hashes in the EVM as the
depth of the tree, and as the gas cost of the snark-friendly Poseidon hash
function is high, the cost of these functions went up to hundreds of thousands
of gas. The AccQueue approach solves this by reducing the number of on-chain
hashes that each user must perform, and making the coordinator responsible for
paying for the gas needed to compute the final Merkle root.</p>
<p>To <em>enqueue</em> a leaf into an AccQueue is to insert it into its rightmost
subtree. When a subtree is full, the next enqueue operation creates a new
subtree. To obtain the Merkle root of all leaves, the coordinator merges all
the subtree roots. When performed on-chain, the <em>merge</em> operation can be
completed in multiple transactions, which is necessary if a single operation
would exceed the block gas limit.</p>
<p>There are two steps to the merge operation:</p>
<p><strong><code>mergeSubRoots(uint256 _numSrQueueOps)</code></strong> This function merges the subroots
to the shortest possible tree, also known as the <em>small subroot tree</em>. For
instance, if the arity of the tree is 2 and the number of subroots is 5, the
shortest possible tree has a depth of 3 (since $2^2=4$ and $2^3=8$).</p>
<p>The <code>_numSrQueueOps</code> parameter restricts the number of number of subroots to
merge per transaction. This allows the entire operation to be performed in
multiple transactions. If it is set to 0, the function will attempt to perform
the operation in one go.</p>
<p><strong><code>merge(uint256 _depth)</code></strong> This function must and can only be run after
<code>mergeSubRoots()</code>. It computes the Merkle root of a tree where the small
subroot tree is the leftmost leaf. The given <code>_depth</code> must be greater than or
equal to the small subroot tree depth.</p>
<h3 id="public-key"><a class="header" href="#public-key">Public key</a></h3>
<p>Each user has an EdDSA public key, and only they know the private key
associated with it.</p>
<h3 id="voice-credit"><a class="header" href="#voice-credit">Voice credit</a></h3>
<p>A unit which denotes the strength of a user's vote for a particular option. In
a quadratic voting use case, users start out with a limited number of voice
credits and spend them on votes.</p>
<h3 id="vote-weight"><a class="header" href="#vote-weight">Vote weight</a></h3>
<p>The number of voice credits which a user wishes to spend on a particular vote
option.</p>
<h3 id="vote-option"><a class="header" href="#vote-option">Vote option</a></h3>
<p>One out of many possible choices which a user may vote for. A vote option is
represented by an index starting from 0. </p>
<h3 id="vote-option-tree"><a class="header" href="#vote-option-tree">Vote option tree</a></h3>
<p>A Merkle tree where each leaf at index \(i\) contains the vote weight for the
corresponding vote option \(i\). </p>
<h3 id="command"><a class="header" href="#command">Command</a></h3>
<p>A command is an instruction from a user to cast a vote for a particular vote
option, a key-change request, or both. Its fields are:</p>
<table><thead><tr><th>Field</th><th>Bits</th><th>Description</th></tr></thead><tbody>
<tr><td><code>stateIndex</code></td><td>50</td><td>The index of the leaf in the state tree which contains the public key used to sign the message. This is used to point to the state leaf to update.</td></tr>
<tr><td><code>newPubKey</code></td><td>253 * 2</td><td>This row refers to two fields: the x- and y-coordinates of the new public key. If no change is desired, it should be that of the current key.</td></tr>
<tr><td><code>voteOptionIndex</code></td><td>50</td><td>The index of the leaf in the vote option tree to vote for.</td></tr>
<tr><td><code>newVoteWeight</code></td><td>50</td><td>In the quadratic voting use case, this is the square root of the number of voice credits a user wishes to spend on this vote.</td></tr>
<tr><td><code>nonce</code></td><td>50</td><td>The nonce.</td></tr>
<tr><td><code>pollId</code></td><td>50</td><td>The ID of the poll for which this vote is meant.</td></tr>
<tr><td><code>salt</code></td><td>253</td><td>A random value to prevent brute-force attacks.</td></tr>
</tbody></table>
<p>With the values provided above an array is generated with length four that is
hashed and signed using the users private key. </p>
<p>This is acheived by packing the <code>stateIndex</code>, <code>voteOptionIndex</code>,
<code>newVoteWeight</code>, <code>nonce</code>, and <code>pollId</code> into a single value. The <code>stateIndex</code> is
added to a leftwise shift of increasing increments of fifty bits to each of
subsequent parameters which are also concatenated, i.e. voteOption is shifted
by 50, voteWeight is shifted by 100 and so on, that then gives a 250-bit value.
This upper-bound limit of 50-bits provides more than enough space to run a poll
with a large number of users while allowing MACI to save on gas by packing
values using the method outlined here. </p>
<p>The hashed array contains this calculated value labeled <code>p</code>, the users public
key (x and y coordinate), and the random salt. When encrypting, the signature
generated from the hashed command array is used in the plaintext of the
message. The plaintext contains both the hashed command array and user's
signture flattened into a single array, where the shared EcDH key will encrypt
and return this new message containing the ciphertext. </p>
<h3 id="message"><a class="header" href="#message">Message</a></h3>
<p>A message is the encrypted version of a command and its signature. </p>
<h3 id="state-queue"><a class="header" href="#state-queue">State queue</a></h3>
<p>The state queue is an AccQueue of state leaves. The Merkle root of all the state leaves represents a mapping of all users to their registered public key and voice credit balance.</p>
<p>The default (zero) leaf value is the nothing-up-my-sleeve value described above.</p>
<h4 id="state-leaf"><a class="header" href="#state-leaf">State Leaf</a></h4>
<p>A state leaf is a user's public key, their voice credit balance, and the timestamp at which they signed up.</p>
<h3 id="poll"><a class="header" href="#poll">Poll</a></h3>
<h4 id="ballot"><a class="header" href="#ballot">Ballot</a></h4>
<p>A ballot represents the outcome of a user's actions during a poll. Specifically, it consists of the user's vote option tree and their next valid nonce.</p>
<p>It is analogous to the slip of paper that a voter uses to indicate their preferred candidates in an election.</p>
<p>The next valid nonce, as described below, allows MACI to prevent replay attacks, and allows users to easily invalidate a vote they wish to use to fool a briber.</p>
<h4 id="ballot-tree"><a class="header" href="#ballot-tree">Ballot tree</a></h4>
<p>Each poll has a tree of ballots. Since each user has one ballot per poll, the ballot tree has the same arity and depth as the state tree. The vote option tree depth, however, is variable, so we precompute the Merkle roots of five empty ballot trees, for vote option tree depths 1-5.</p>
<p>An empty ballot tree has an empty ballot as its default leaf. An empty ballot with a vote option tree of depth 2 would therefore be computed as such:</p>
<pre><code>hashLeftRight(
    0, // the nonce
    root(2, 0, 5) // a quinary Merkle root of a tree with depth 5 and default leaf 0
)
</code></pre>
<h4 id="message-queue"><a class="header" href="#message-queue">Message queue</a></h4>
<p>Each poll has a message queue. Like the state queue, each message queue is an
AccQueue. Each leaf is the hash of a message.</p>
<p>The default (zero) leaf value is the nothing-up-my-sleeve value described
above.</p>
<h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<p>You need the following to use MACI:</p>
<ul>
<li>An x86-64 system</li>
<li>A Linux system, preferably a Debian-based distribution like Ubuntu</li>
<li>NodeJS. Use <a href="https://github.com/nvm-sh/nvm"><code>nvm</code></a> to install it. MACI has
been tested with Node 15.</li>
<li>The <code>libgmp-dev</code> <code>nlohmann-json3-dev</code> <code>nasm</code> and <code>g++</code> Debian/Ubuntu
packages. They are needed to run <code>circom-helper</code>, which in turn is used to
develop and test zk-SNARK circuits.</li>
<li>The <a href="https://github.com/iden3/rapidsnark"><code>rapidsnark</code></a> tool.</li>
</ul>
<h2 id="installation-1"><a class="header" href="#installation-1">Installation</a></h2>
<h3 id="install-rapidsnark"><a class="header" href="#install-rapidsnark">Install <code>rapidsnark</code></a></h3>
<p>First, install dependencies:</p>
<pre><code class="language-bash">sudo apt-get install build-essential libgmp-dev libsodium-dev nasm git
</code></pre>
<p>Next, clone <code>rapidsnark</code> and build it:</p>
<pre><code class="language-bash">git clone https://github.com/iden3/rapidsnark.git &amp;&amp; \
cd rapidsnark &amp;&amp; \
git checkout 1c13721de4a316b0b254c310ccec9341f5e2208e

npm install &amp;&amp; \
git submodule init &amp;&amp; \
git submodule update &amp;&amp; \
npx task createFieldSources &amp;&amp; \
npx task buildProver
</code></pre>
<p>Note the location of the <code>rapidsnark</code> binary (e.g.
<code>/home/user/rapidsnark/build/prover</code>).</p>
<h3 id="install-maci"><a class="header" href="#install-maci">Install MACI</a></h3>
<pre><code class="language-bash">git clone https://github.com/appliedzkp/maci.git &amp;&amp; \
cd maci &amp;&amp; \
npm i &amp;&amp; \
npm run bootstrap &amp;&amp; \
npm run build
</code></pre>
<p>Install dependencies for <code>circom-helper</code> and <code>zkey-manager</code>:</p>
<pre><code class="language-bash">sudo apt-get install libgmp-dev nlohmann-json3-dev nasm g++
</code></pre>
<h3 id="download-zkey-files"><a class="header" href="#download-zkey-files">Download <code>.zkey</code> files</a></h3>
<p>MACI has two zk-SNARK circuits. Each circuit is parameterised. There should one
<code>.zkey</code> file for each circuit and set of parameters.</p>
<p>Unless you wish to generate a fresh set of <code>.zkey</code> files, you should obtain
them from someone who has performed a multi-party trusted setup for said
circuits..</p>
<p>Note the locations of the <code>.zkey</code> files as the CLI requires them as
command-line flags.</p>
<h3 id="generate-zkey-files"><a class="header" href="#generate-zkey-files">Generate <code>.zkey</code> files</a></h3>
<p>If you wish to generate <code>.zkey</code> files from scratch, first navigate to <code>cli/</code>
and edit <code>zkeys.config.yml</code>. Set the parameters you need.</p>
<p>Next, run the following to compile the circuits with parameters you specified:</p>
<pre><code class="language-bash">npx zkey-manager compile -c zkeys.config.yml
</code></pre>
<p>Next, download the <code>.ptau</code> file:</p>
<pre><code class="language-bash">npx zkey-manager downloadPtau -c zkeys.config.yml
</code></pre>
<p>Finally, generate the <code>.zkey</code> files. This may require a lot of memory and time.</p>
<pre><code class="language-bash">npx zkey-manager genZkeys -c zkeys.config.yml
</code></pre>
<h1 id="command-line-interface"><a class="header" href="#command-line-interface">Command-line interface</a></h1>
<p>MACI provides a command-line interface that allows for effective deployment and
testing. Applications that build on top of MACI, such as
<a href="https://clr.fund/">clr.fund</a>, implement their own web UIs.</p>
<p>Note that all the example commands default to a local Ethereum testnet at
<code>http://localhost:8545</code>, and use the Ethereum private key
<code>0xc87509a1c067bbde78beb793e6fa76530b6382a4c0241e5e4a9ec0a0f44dc0d3</code>. Do not
send any real funds to the address generated by this key.</p>
<p>For testing purposes, you can run:</p>
<pre><code class="language-bash"># in maci/contracts
npm run hardhat
</code></pre>
<h2 id="subcommands"><a class="header" href="#subcommands">Subcommands</a></h2>
<table><thead><tr><th>Role</th><th>Action</th><th>Subcommand</th></tr></thead><tbody>
<tr><td>User</td><td>Generate MACI keypair</td><td><code>genMaciKeypair</code></td></tr>
<tr><td>User</td><td>Generate MACI public key</td><td><code>genMaciPubkey</code></td></tr>
<tr><td>Coordinator</td><td>Deploy VkRegistry</td><td><code>deployVkRegistry</code></td></tr>
<tr><td>Coordinator</td><td>Set verifying keys</td><td><code>setVerifyingKeys</code></td></tr>
<tr><td>Coordinator</td><td>Create MACI instance</td><td><code>create </code></td></tr>
<tr><td>Coordinator</td><td>Deploy a new poll</td><td><code>deployPoll</code></td></tr>
<tr><td>Coordinator</td><td>Deploy a new poll processor and tallyer</td><td><code>deployPpt</code></td></tr>
<tr><td>User</td><td>Sign up</td><td><code>signup</code></td></tr>
<tr><td>User</td><td>Change key / vote</td><td><code>publish</code></td></tr>
<tr><td>Coordinator</td><td>Merge state tree</td><td><code>mergeSignups</code></td></tr>
<tr><td>Coordinator</td><td>Merge message tree</td><td><code>mergeMessages</code></td></tr>
<tr><td>Coordinator</td><td>Generate message processing and vote tallying proofs</td><td><code>genProofs</code></td></tr>
<tr><td>Coordinator</td><td>Submit proofs</td><td><code>proveOnChain</code></td></tr>
<tr><td>Coordinator</td><td>Process and tally all votes without producing proofs</td><td><code>processAndTallyWithoutProofs</code></td></tr>
<tr><td>Coordinator</td><td>Roll back message processing and vote tallying in the MACI contract</td><td><code>coordinatorReset</code></td></tr>
</tbody></table>
<h2 id="public-and-private-key-format"><a class="header" href="#public-and-private-key-format">Public and private key format</a></h2>
<p>MACI uses private keys in the BabyJub field for operations which occur within
zk-SNARKs, such as decrypting messages or signing commands. As MACI is deployed
on Ethereum, we seek to avoid confusing BabyJub private keys with Ethereum
private keys. To that end, users should pass serialized formats of public and
private keys to this CLI. We use <code>maci-domainobj</code>'s <code>PrivKey.serialize</code> and
<code>PubKey.serialize</code> functions to do so. </p>
<p>Examples of serialized public and private keys:</p>
<pre><code>Private key: macisk.49953af3585856f539d194b46c82f4ed54ec508fb9b882940cbe68bbc57e59e
Public key:  macipk.495140c99cbc090c74363d5e3f32705a92a9e1df8e5ebe2fd6831de9c813f01f
</code></pre>
<h3 id="coordinator-deploy-vkregistry"><a class="header" href="#coordinator-deploy-vkregistry">Coordinator: Deploy VkRegistry</a></h3>
<p>This command deploys an instance of a VkRegistry contract. Multiple MACI
contracts can refer to the same VkRegistry as long as they are all owned (via
<code>Ownable.sol</code>) by the same account.</p>
<p>Example usage:</p>
<pre><code class="language-bash">ETH_SK=0xc87509a1c067bbde78beb793e6fa76530b6382a4c0241e5e4a9ec0a0f44dc0d3 \
ETH_PROVIDER=http://localhost:8545 \
node build/index.js deployVkRegistry
</code></pre>
<p>Example output:</p>
<pre><code>VkRegistry: 0x8CdaF0CD259887258Bc13a92C0a6dA92698644C0
</code></pre>
<h3 id="coordinator-set-verifying-keys"><a class="header" href="#coordinator-set-verifying-keys">Coordinator: Set verifying keys</a></h3>
<p>Note that the filename of the <code>.zkey</code> files must follow this format:</p>
<pre><code>ProcessMessages_&lt;STATE_TREE_DEPTH&gt;-&lt;MSG_TREE_DEPTH&gt;-&lt;MSG_SUBTREE_DEPTH&gt;-&lt;VOTE_OPTION_TREE_DEPTH&gt;.test.&lt;CONTRIBUTION_NUM&gt;.zkey
TallyVotes_&lt;STATE_TREE_DEPTH&gt;-&lt;INT_STATE_TREE_DEPTH&gt;-&lt;VOTE_OPTION_TREE_DEPTH&gt;&gt;.test.&lt;CONTRIBUTION_NUM&gt;&gt;.zkey
</code></pre>
<p>Example usage:</p>
<pre><code class="language-bash">ETH_SK=0xc87509a1c067bbde78beb793e6fa76530b6382a4c0241e5e4a9ec0a0f44dc0d3 \
ETH_PROVIDER=http://localhost:8545 \
node build/index.js setVerifyingKeys \
    -s 10 -i 1 -m 2 -v 2 -b 1 \
    -p ./zkeys/ProcessMessages_10-2-1-2.test.0.zkey \
    -t ./zkeys/TallyVotes_10-1-2.test.0.zkey \
    -k 0x8CdaF0CD259887258Bc13a92C0a6dA92698644C0                                                       
</code></pre>
<p>Example output:</p>
<pre><code>Generating ./zkeys/ProcessMessages_10-2-1-2.test.0.zkey.vk.json, please wait...
Generating ./zkeys/TallyVotes_10-1-2.test.0.zkey.vk.json, please wait...
Transaction hash: 0x582631c36a4e21e0b65c3f9100c6343408c8683a36ded36fc02a9be07fa079e8
</code></pre>
<h3 id="coordinator-create-maci-instance"><a class="header" href="#coordinator-create-maci-instance">Coordinator: Create MACI instance</a></h3>
<p>Example usage:</p>
<pre><code class="language-bash">ETH_SK=0xc87509a1c067bbde78beb793e6fa76530b6382a4c0241e5e4a9ec0a0f44dc0d3 \
ETH_PROVIDER=http://localhost:8545 \
node build/index.js create -k 0x8CdaF0CD259887258Bc13a92C0a6dA92698644C0
</code></pre>
<p>Example output:</p>
<pre><code>Deploying Poseidon Contracts
Deploying Poseidon
Linking Poseidon libraries
Linking Poseidon libraries
Linking Poseidon libraries
Deploying MACI
Transferring PollFactory ownership to MACI
Transferring MessageAqFactory ownership to PollFactory
Initialising MACI
PollProcessorAndTallyer: 0xAa588d3737B611baFD7bD713445b314BD453a5C8
MACI: 0xf204a4Ef082f5c04bB89F7D5E6568B796096735a
</code></pre>
<h3 id="coordinator-deploy-poll"><a class="header" href="#coordinator-deploy-poll">Coordinator: Deploy poll</a></h3>
<p>Example usage:</p>
<pre><code class="language-bash">ETH_SK=0xc87509a1c067bbde78beb793e6fa76530b6382a4c0241e5e4a9ec0a0f44dc0d3 \
ETH_PROVIDER=http://localhost:8545 \
node ./build/index.js deployPoll \
    -x 0xf204a4Ef082f5c04bB89F7D5E6568B796096735a \
    -pk macipk.495140c99cbc090c74363d5e3f32705a92a9e1df8e5ebe2fd6831de9c813f01f \
    -t 120 -g 25 -mv 25 -i 1 -m 2 -b 1 -v 2
</code></pre>
<p>Example output:</p>
<pre><code>Deploying Verifier
Deploying PollProcessorAndTallyer
Verifier: 0xEcFcaB0A285d3380E488A39B4BB21e777f8A4EaC
Poll ID: 0
Poll contract: 0x440B7f9b667420af04e88d4dA0B9122E05cCa5A0
</code></pre>
<h3 id="user-sign-up"><a class="header" href="#user-sign-up">User: sign up</a></h3>
<p>Example usage:</p>
<pre><code class="language-bash">ETH_SK=0xc87509a1c067bbde78beb793e6fa76530b6382a4c0241e5e4a9ec0a0f44dc0d3 \
ETH_PROVIDER=http://localhost:8545 \
node ./build/index.js signup \
    -p macipk.b8590fdba5e9cde5606dad5db384be4d253d0a2064d1e03f9600ee021a7ebe16 \
    -x 0xf204a4Ef082f5c04bB89F7D5E6568B796096735a
</code></pre>
<p>Example output:</p>
<pre><code>Transaction hash: 0xcae04f618a0b45896732632121248c312cbc68584519c1e43932b110da9078bc
State index: 0
</code></pre>
<h3 id="user-publish-message"><a class="header" href="#user-publish-message">User: publish message</a></h3>
<p>Example usage: </p>
<pre><code class="language-bash">ETH_SK=0xc87509a1c067bbde78beb793e6fa76530b6382a4c0241e5e4a9ec0a0f44dc0d3 \
ETH_PROVIDER=http://localhost:8545 \
node build/index.js publish \
    -p macipk.b8590fdba5e9cde5606dad5db384be4d253d0a2064d1e03f9600ee021a7ebe16 \
    -sk macisk.2ae4f199bf3925a2407f7c775c9261f351ab861d8e9ecbb84622bdd3f6d41b08 \
    -x 0xf204a4Ef082f5c04bB89F7D5E6568B796096735a \
    -i 1 -v 0 -w 9 -n 1 -o 0
</code></pre>
<h3 id="coordinator-merge-state-tree"><a class="header" href="#coordinator-merge-state-tree">Coordinator: merge state tree</a></h3>
<p>Example usage:</p>
<pre><code class="language-bash">ETH_SK=0xc87509a1c067bbde78beb793e6fa76530b6382a4c0241e5e4a9ec0a0f44dc0d3 \
ETH_PROVIDER=http://localhost:8545 \
node build/index.js mergeSignups -x 0xf204a4Ef082f5c04bB89F7D5E6568B796096735a -o 0
</code></pre>
<h3 id="coordinator-merge-message-tree"><a class="header" href="#coordinator-merge-message-tree">Coordinator: merge message tree</a></h3>
<p>Example usage:</p>
<pre><code class="language-bash">ETH_SK=0xc87509a1c067bbde78beb793e6fa76530b6382a4c0241e5e4a9ec0a0f44dc0d3 \
ETH_PROVIDER=http://localhost:8545 \
node build/index.js mergeMessages -x 0xf204a4Ef082f5c04bB89F7D5E6568B796096735a -o 0
</code></pre>
<h3 id="coordinator-generate-proofs"><a class="header" href="#coordinator-generate-proofs">Coordinator: generate proofs</a></h3>
<p>Example usage:</p>
<pre><code class="language-bash">node build/index.js genProofs -x 0xf204a4Ef082f5c04bB89F7D5E6568B796096735a \
    -sk macisk.49953af3585856f539d194b46c82f4ed54ec508fb9b882940cbe68bbc57e59e \
    -q 0xAa588d3737B611baFD7bD713445b314BD453a5C8 \
    -o 0 \
    -t tally.json \
    -f proofs.json \
    -r ~/rapidsnark/build/prover \
    -wp ./zkeys/ProcessMessages_10-2-1-2.test \
    -wt ./zkeys/TallyVotes_10-1-2.test \
    -zp ./zkeys/ProcessMessages_10-2-1-2.test.0.zkey \
    -zt ./zkeys/TallyVotes_10-1-2.test.0.zkey
</code></pre>
<h3 id="anyone-verify-tally"><a class="header" href="#anyone-verify-tally">Anyone: verify tally</a></h3>
<p>Example usage:</p>
<pre><code class="language-bash">node build/index.js verify \
    -x 0xf204a4Ef082f5c04bB89F7D5E6568B796096735a \
    -o 0 \
    -t tally.json \
    -q 0xEcFcaB0A285d3380E488A39B4BB21e777f8A4EaC
</code></pre>
<h2 id="demonstration"><a class="header" href="#demonstration">Demonstration</a></h2>
<p>TODO</p>
<h1 id="circuits"><a class="header" href="#circuits">Circuits</a></h1>
<p>MACI has two zk-SNARK circuits:</p>
<ol>
<li><code>ProcessMessages.circom</code>, which takes a batch of messages, and updates the
state and ballot trees according to the contents of said messages.</li>
<li><code>TallyVotes.circom</code>, which counts votes from users' ballots, batch by batch.</li>
</ol>
<p>Each circuit is parameterised and it is important to set the right parameters
to your use case. For example, if you want to support up to 3125 messages, the message tree depth parameter should be set to <code>5</code> (as \(5^5 = 3125\)).</p>
<p>Next, navigate to the <code>cli/</code> directory and edit <code>zkeys.config.yml</code>.</p>
<p>This config file defines the parameters required for MACI's circuits.</p>
<h3 id="message-processing-1"><a class="header" href="#message-processing-1">Message processing</a></h3>
<table><thead><tr><th>#</th><th>Parameter</th><th>Description</th></tr></thead><tbody>
<tr><td>0</td><td>State tree depth</td><td>Should be set to 10. Allows 9,765,625 signups.</td></tr>
<tr><td>1</td><td>Message tree depth</td><td>Allows \(5^{n}\) votes or key-change messages.</td></tr>
<tr><td>2</td><td>Message batch tree depth</td><td>Allows \(5^{n}\) messages to be processed per batch.</td></tr>
<tr><td>3</td><td>Vote option tree depth</td><td>Allows \(5^{n}\) vote options.</td></tr>
</tbody></table>
<h3 id="vote-tallying-1"><a class="header" href="#vote-tallying-1">Vote tallying</a></h3>
<table><thead><tr><th>#</th><th>Parameter</th><th>Description</th></tr></thead><tbody>
<tr><td>0</td><td>State tree depth</td><td>Should be set to 10. Allows 9,765,625 signups.</td></tr>
<tr><td>1</td><td>State leaf batch depth</td><td>Allows \(5^{n}\) users' votes to be processed per batch.</td></tr>
<tr><td>2</td><td>Message batch tree depth</td><td>Allows \(5^{n}\) messages to be processed per batch.</td></tr>
</tbody></table>
<h2 id="compile-circuits"><a class="header" href="#compile-circuits">Compile circuits</a></h2>
<p>Run:</p>
<pre><code class="language-bash">npx zkey-manager compile -c ./zkeys.config.yml
</code></pre>
<p>The larger the trees, the more time this process may take. You may also need a
machine with a very large amount of memory.</p>
<h2 id="measure-the-circuit-sizes"><a class="header" href="#measure-the-circuit-sizes">Measure the circuit sizes</a></h2>
<p>The size of a circuit is denoted by its number of constraints. The larger this
number, the more time it takes to compile it, generate its <code>.zkey</code> file, and
perform phase 2 contributions.</p>
<p>Run this command to measure a circuit:</p>
<pre><code class="language-bash">npx snarkjs r1cs info CIRCUIT_NAME.circom
</code></pre>
<h2 id="download-the-ptau-file"><a class="header" href="#download-the-ptau-file">Download the <code>.ptau</code> file</a></h2>
<p>This file should be the result of the Perpetual Powers of Tau trusted setup
contribution which <a href="https://blog.hermez.io/hermez-cryptographic-setup/">Hermez Network
selected</a>.</p>
<p>Run:</p>
<pre><code class="language-bash">npx zkey-manager downloadPtau -c ./zkeys.config.yml
</code></pre>
<p><code>zkey-manager</code> will select the smallest <code>.ptau</code> file that fits the largest
circuit specified in <code>zkeys.config.yml</code>. </p>
<h2 id="generate-zkey-files-1"><a class="header" href="#generate-zkey-files-1">Generate <code>.zkey</code> files</a></h2>
<p>Run:</p>
<pre><code class="language-bash">npx zkey-manager genZkeys -c ./zkeys.config.yml
</code></pre>
<p>This generates the initial <code>.zkey</code> files for each circuit.</p>
<p>You should perform at least one contribution to each circuit, even if you
choose not to perform a multi-party trusted setup.</p>
<h1 id="trusted-setup"><a class="header" href="#trusted-setup">Trusted setup</a></h1>
<p>MACI currently uses Groth16 zk-SNARKs written in <code>circom</code>. Teams who wish to
build on MACI may choose to perform a multi-party trusted setup. This allows
observers to have a higher degree of confidence that the coordinator cannot
generate fake proofs. Some teams, however, may forgo the trusted setup.</p>
<p>There are two possible reasons for doing so: if a team does not intend
to manage a large amount of value, and if their users accept that the risk of
coordinator misbehaviour is insufficient to justify doing the work nof a
trusted setup. After all, MACI's security model presumes a trusted coordinator.</p>
<p>In any case, MACI can be relatively easily modified to support PLONK, which
does not require a circuit-specific trusted setup. Its circuits, written in
<a href="https://github.com/iden3/circom"><code>circom</code></a>, are compatible with Fluidex's
<a href="https://github.com/Fluidex/plonkit"><code>plonkit</code></a> tool. The downside to using
PLONK is that proof generation is not as optimised as it is for Groth16.</p>
<h2 id="how-to-run-the-trusted-setup"><a class="header" href="#how-to-run-the-trusted-setup">How to run the trusted setup</a></h2>
<p>First, follow the instructions in the <a href="./installation.html">Installation</a>
section to install dependencies for MACI.</p>
<p>Next, configure and compile circuits following instructions in
<a href="./circuits.html">Circuits</a>.</p>
<p>Finally, use the <a href="https://github.com/appliedzkp/multisetups"><code>multisetups</code></a>
tool to do this.</p>
<p>You should perform at least one contribution to each circuit, even if you
choose not to perform a multi-party trusted setup.</p>
<p>We don't recommend a browser-based trusted setup (which <a href="https://ceremony.tornado.cash/">Tornado
Cash</a> and <a href="https://mpc.zkopru.network/">Zkopru</a>
used) for the MACI circuits as they are too large to be feasibly processed in
the browser.</p>
<h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<h2 id="contracts"><a class="header" href="#contracts">Contracts</a></h2>
<p>First, compile the contracts.</p>
<p>From the main <code>maci/</code> directory, run:</p>
<pre><code class="language-bash">cd contracts &amp;&amp; \
npm run compileSol
</code></pre>
<p>Run Hardhat Network (a local Ethereum testnet) in a separate terminal:</p>
<pre><code class="language-bash">cd contracts &amp;&amp; \
npm run hardhat
</code></pre>
<h2 id="cli"><a class="header" href="#cli">CLI</a></h2>
<p>You can test the CLI locally. First, you need to either generate <code>.zkey</code> files,
or download them. Do not use these testing <code>.zkey</code> files in production.</p>
<h3 id="download-zkey-files-1"><a class="header" href="#download-zkey-files-1">Download <code>.zkey</code> files</a></h3>
<p>MACI has two zk-SNARK circuits. Each circuit is parameterised. There should one
<code>.zkey</code> file for each circuit and set of parameters.</p>
<p>Unless you wish to generate a fresh set of <code>.zkey</code> files, you should obtain
them from someone who has performed a multi-party trusted setup for said
circuits..</p>
<p>Note the locations of the <code>.zkey</code> files as the CLI requires them as
command-line flags.</p>
<p>From the main <code>maci/</code> directory, run:</p>
<pre><code class="language-bash">cd cli &amp;&amp;
mkdir -p zkeys &amp;&amp; \
wget -O zkeys/ProcessMessages_10-2-1-2.test.0.zkey https://macitestcircuits.blob.core.windows.net/test/ProcessMessages_10-2-1-2.test.0.zkey &amp;&amp; \
wget -O zkeys/TallyVotes_10-1-2.test.0.zkey https://macitestcircuits.blob.core.windows.net/test/TallyVotes_10-1-2.test.0.zkey
</code></pre>
<h3 id="compile-or-download-the-witness-generation-binaries"><a class="header" href="#compile-or-download-the-witness-generation-binaries">Compile or download the witness generation binaries</a></h3>
<p>You may download precompiled witness generation binaries but there is no guarantee that they will work on your machine.</p>
<pre><code class="language-bash">mkdir -p zkeys &amp;&amp; \
wget -O ProcessMessages_10-2-1-2.test https://macitestcircuits.blob.core.windows.net/test/ProcessMessages_10-2-1-2.test &amp;&amp; \
wget -O TallyVotes_10-1-2.test https://macitestcircuits.blob.core.windows.net/test/TallyVotes_10-1-2.test
</code></pre>
<p>Otherwise, you may compile them yourself.</p>
<p>From the main <code>maci/cli</code> directory, run:</p>
<pre><code>npx zkey-manager compile -c ./zkeys.config.yml
</code></pre>
<p>You should see the following files in <code>cli/zkeys/</code>:</p>
<pre><code>ProcessMessages_10-2-1-2.test
ProcessMessages_10-2-1-2.test.0.zkey
TallyVotes_10-1-2.test
TallyVotes_10-1-2.test.0.zkey
</code></pre>
<h3 id="check-the-rapidsnark-binary"><a class="header" href="#check-the-rapidsnark-binary">Check the Rapidsnark binary</a></h3>
<p>Next, ensure that the <code>rapidsnark</code> <code>prover</code> binary is in
<code>~/rapidsnark/build/prover</code>.</p>
<h3 id="run-cli-tests"><a class="header" href="#run-cli-tests">Run CLI tests</a></h3>
<p>In <code>maci/cli/</code>, run:</p>
<pre><code class="language-bash">./test.sh
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
