import * as fs from 'fs'
import * as path from 'path'
import { Circuit } from 'snarkjs'
const compiler = require('circom')

import { str2BigInt } from './utils'
import { compileAndLoadCircuit } from '../'
import { config } from 'maci-config'
import { MaciState } from 'maci-core'

import {
    Keypair,
    StateLeaf,
    Command,
    Message,
    PubKey,
} from 'maci-domainobjs'

import {
    IncrementalMerkleTree,
    genRandomSalt,
    Plaintext,
    hash,
    SnarkBigInt,
    PrivKey,
    bigInt,
    stringifyBigInts,
    NOTHING_UP_MY_SLEEVE,
} from 'maci-crypto'

import {
    SnarkProvingKey,
    SnarkVerifyingKey,
    genProof,
    genPublicSignals,
    verifyProof,
    parseVerifyingKeyJson,
} from 'libsemaphore'

jest.setTimeout(1200000)

const provingKeyPath = path.join(__dirname, '../../build/batchUstPk.bin')
const provingKey: SnarkProvingKey = fs.readFileSync(provingKeyPath)

const verifyingKeyPath = path.join(__dirname, '../../build/batchUstVk.json')
const verifyingKey: SnarkVerifyingKey = parseVerifyingKeyJson(fs.readFileSync(verifyingKeyPath).toString())

const batchSize = config.maci.messageBatchSize
const stateTreeDepth = config.maci.merkleTrees.stateTreeDepth
const messageTreeDepth = config.maci.merkleTrees.messageTreeDepth
const voteOptionTreeDepth = config.maci.merkleTrees.voteOptionTreeDepth
const voteOptionsMaxIndex = config.maci.voteOptionsMaxLeafIndex
const initialVoiceCreditBalance = config.maci.initialVoiceCreditBalance

const randomRange = (min: number, max:number) => {
  return Math.floor(Math.random() * (max - min) + min)
}

// Set up keypairs
const user = new Keypair()
const coordinator = new Keypair()

describe('State tree root update verification circuit', () => {
    let circuit 

    const maciState = new MaciState(
        coordinator,
        stateTreeDepth,
        messageTreeDepth,
        voteOptionTreeDepth,
        NOTHING_UP_MY_SLEEVE,
        voteOptionsMaxIndex,
    )

    beforeAll(async () => {
        circuit = await compileAndLoadCircuit('batchUpdateStateTree_test.circom')

        // Sign up the user
        maciState.signUp(user.pubKey, initialVoiceCreditBalance)
    })

    it('BatchUpdateStateTree should produce the correct state root', async () => {
        // Generate four valid messages from the same user
        const voteWeight = bigInt(2)
        const totalVoiceCreditsSpent = bigInt(4) * voteWeight.pow(bigInt(2))
        let commands: Command[] = []
        let messages: Message[] = []
        const stateRootBefore = maciState.genStateRoot()

        for (let i = 0; i < 4; i++) {
            const command = new Command(
                bigInt(1),
                user.pubKey,
                bigInt(0),
                voteWeight,
                bigInt(i + 1),
                genRandomSalt(),
            )
            const signature = command.sign(user.privKey)
            const sharedKey = Keypair.genEcdhSharedKey(user.privKey, coordinator.pubKey)
            const message = command.encrypt(signature, sharedKey)

            commands.push(commands)
            messages.push(message)

            maciState.publishMessage(message, user.pubKey)
        }

        const randomStateLeaf = StateLeaf.genRandomLeaf()

        // Generate circuit inputs
        const circuitInputs = 
            maciState.genBatchUpdateStateTreeCircuitInputs(
                0,
                batchSize,
                randomStateLeaf,
            )
        debugger

        // Calculate the witness
        const witness = circuit.calculateWitness(circuitInputs)
        //expect(circuit.checkWitness(witness)).toBeTruthy()

        //// Get the circuit-generated root
        //const idx = circuit.getSignalIdx('main.root')
        //const circuitNewStateRoot = witness[idx].toString()

        //// Process the batch of messages
        //maciState.batchProcessMessage(
            //0,
            //batchSize,
            //randomStateLeaf,
        //)

        //const stateRootAfter = maciState.genStateRoot()

        //expect(stateRootBefore.toString()).not.toEqual(stateRootAfter)

        //// After we run process the message via maciState.processMessage(),
        //// the root generated by the circuit should match
        //expect(circuitNewStateRoot.toString()).toEqual(stateRootAfter.toString())
        //debugger
    })
})

//const createUser = (
    //voteOptionLength: SnarkBigInt,
    //creditBalance: SnarkBigInt = bigInt(125),
    //nonce: SnarkBigInt = bigInt(0)
//) => {
    //// Helper function to create a user and their associated vote option tree
    //const user = new Keypair()

    //const ephemeralKeypair = new Keypair()

    //const userVoteOptionTree = new IncrementalMerkleTree(voteOptionTreeDepth, NOTHING_UP_MY_SLEEVE)
    //const voteWeight = bigInt(0)
    //for (let i = 0; i < voteOptionLength; i++) {
        //// Vote for no-one by default
        //userVoteOptionTree.insert(voteWeight)
    //}

    //const userStateLeaf = new StateLeaf(
        //user.pubKey,
        //userVoteOptionTree.root,
        //creditBalance,
        //nonce,
    //)

    //return {
        //user,
        //ephemeralKeypair,
        //nonce,
        //userStateLeaf,
        //userVoteOptionTree,
    //}
//}

/*
 * Returns a state tree and vote option tree based on a supplied message.
 * The trees returned are 
 */

//describe('Batch state tree root update verification circuit', () => {
    //let circuit

    //// Set up keypairs
    //const user1 = new Keypair()
    //const coordinator = new Keypair()
    //const ephemeralKeypair = new Keypair()

    //beforeAll(async () => {
        //circuit = await compileAndLoadCircuit('batchUpdateStateTree_test.circom')
    //})

    //it('should process valid inputs correctly', async () => {
        //// Construct the trees
        //const msgTree = new IncrementalMerkleTree(
            //messageTreeDepth,
            //NOTHING_UP_MY_SLEEVE,
        //)

        //let stateTree = new IncrementalMerkleTree(
            //stateTreeDepth,
            //NOTHING_UP_MY_SLEEVE,
        //)

        //let stateLeaves: StateLeaf[] = []

        //// Register users into the stateTree.
        //// stateTree index 0 is a random leaf used to insert random data when the
        //// decryption fails
        //stateTree.insert(NOTHING_UP_MY_SLEEVE)
        //stateLeaves.push(NOTHING_UP_MY_SLEEVE)

        //// Vote option length (not tree depth)
        //const voteOptionLength = 2 ** voteOptionTreeDepth
        //const batchSize = 4

        //// Create and register users
        //let users = {}
        //for (let i = 0; i < batchSize; i++) {
            //const {
                //user,
                //ephemeralKeypair,
                //nonce,
                //userStateLeaf,
                //userVoteOptionTree,
            //} = createUser(voteOptionLength)

            //stateTree.insert(userStateLeaf.hash())
            //stateLeaves.push(userStateLeaf)

            //const stateTreeIndex = bigInt(stateTree.nextIndex - 1)

            //users[i] = {
                //user,
                //ephemeralKeypair,
                //nonce,
                //userStateLeaf,
                //userVoteOptionTree,
                //userIndex: stateTreeIndex,
            //}
        //}

        //// Create user commands and messages
        //let batch: any[] = []

        //for (let i = 0; i < batchSize; i++) {
            //const voteOptionIndex = randomRange(0, voteOptionLength)
            //const voteOptionWeight = randomRange(0, 8)
            //const user = users[i]
            //const salt = genRandomSalt()

            //const command = new Command(
                //user.userIndex,
                //user.user.pubKey,
                //bigInt(voteOptionIndex),
                //bigInt(voteOptionWeight),
                //user.nonce + bigInt(1),
                //salt
            //)

            //const sig = command.sign(user.user.privKey)

            //const sharedKey = Keypair.genEcdhSharedKey(
                //user.ephemeralKeypair.privKey,
                //coordinator.pubKey,
            //)
            //const message = command.encrypt(sig, sharedKey)

            //// Insert a message into the msg tree
            //msgTree.insert(message.hash())

            //batch.push({ command, message })
        //}

        //// Generate circuit inputs
        //const msgTreeBatchStartIndex = 0
        //let msgTreeBatchPathElements: SnarkBigInt[] = []
        //let stateTreeBatch: StateLeaf[] = []
        //let stateTreeBatchRoot: SnarkBigInt[] = []
        //let stateTreeBatchPathElements: SnarkBigInt[] = []
        //let stateTreeBatchPathIndices: SnarkBigInt[] = []
        //let userVoteOptionsBatchRoot: SnarkBigInt[] = []
        //let userVoteOptionsBatchPathElements: SnarkBigInt[] = []
        //let userVoteOptionsBatchPathIndices: SnarkBigInt[] = []
        //let voteOptionTreeBatchLeafRaw: SnarkBigInt[] = []
        //let ecdhPublicKeyBatch: PubKey[] = []

        //for (let i = 0; i < batchSize; i++) {
            //// Get relevant Merkle paths
            //const { command, message } = batch[i]
            //const user = users[i]

            //const [
                //msgTreePathElements,
                //_,
            //] = msgTree.getPathUpdate(i)

            //msgTreeBatchPathElements.push(msgTreePathElements)

            //const [
                //stateTreePathElements,
                //stateTreePathIndices
            //] = stateTree.getPathUpdate(user.userIndex)

            //stateTreeBatch.push(stateLeaves[user.userIndex])

            //stateTreeBatchRoot.push(stateTree.root)
            //stateTreeBatchPathElements.push(stateTreePathElements)
            //stateTreeBatchPathIndices.push(stateTreePathIndices)

            //const userVoteOptionIndex = command.voteOptionIndex

            //const [
                //userVoteOptionsPathElements,
                //userVoteOptionsPathIndices
            //] = user.userVoteOptionTree.getPathUpdate(userVoteOptionIndex)

            //userVoteOptionsBatchRoot.push(user.userVoteOptionTree.root)
            //userVoteOptionsBatchPathElements.push(userVoteOptionsPathElements)
            //userVoteOptionsBatchPathIndices.push(userVoteOptionsPathIndices)

            //voteOptionTreeBatchLeafRaw.push(user.userVoteOptionTree.getLeaf(userVoteOptionIndex))

            //ecdhPublicKeyBatch.push(user.ephemeralKeypair.pubKey)

            //const ecdhSharedKey = Keypair.genEcdhSharedKey(
                //coordinator.privKey,
                //user.ephemeralKeypair.pubKey,
            //)

            //// Process the message
            //const data = processMessage(
                //ecdhSharedKey,
                //message,
                //stateLeaves[command.stateIndex],
                //stateTree,
                //user.userVoteOptionTree
            //)

            //stateTree = data.stateTree
            //user.userVoteOptionTree = data.userVoteOptionTree
        //}

        //const stateTreeMaxIndex = bigInt(stateTree.nextIndex - 1)
        //const voteOptionsMaxIndex = bigInt(2 ** voteOptionTreeDepth - 1)

        //// After processing all commands, insert a random leaf
        //const randomLeafRoot = stateTree.root
        //const randomStateLeaf = StateLeaf.genRandomLeaf()
        //const [randomLeafPathElements, _] = stateTree.getPathUpdate(0)

        //const circuitInputs = genBatchUstInputs(
            //coordinator,
            //batch.map((x) => x.message),
            //ecdhPublicKeyBatch,
            //msgTree,
            //msgTreeBatchPathElements,
            //msgTreeBatchStartIndex,
            //randomStateLeaf,
            //randomLeafRoot,
            //randomLeafPathElements,
            //voteOptionTreeBatchLeafRaw,
            //userVoteOptionsBatchRoot,
            //userVoteOptionsBatchPathElements,
            //userVoteOptionsBatchPathIndices,
            //voteOptionsMaxIndex,
            //stateTreeBatch,
            //stateTreeMaxIndex,
            //stateTreeBatchRoot,
            //stateTreeBatchPathElements,
            //stateTreeBatchPathIndices,
        //)

        //const witness = circuit.calculateWitness(circuitInputs)

        //expect(circuit.checkWitness(witness)).toBeTruthy()

        //const idx = circuit.getSignalIdx('main.root')
        //const circuitNewStateRoot = witness[idx].toString()

        //// Update the state tree with a random leaf
        //stateTree.update(0, randomStateLeaf.hash())
        //stateLeaves[0] = randomStateLeaf

        //expect(stateTree.root.toString()).toEqual(circuitNewStateRoot)

        //const publicSignals = genPublicSignals(witness, circuit)

        //expect(publicSignals).toHaveLength(19)
    //})
//})
